#!/usr/bin/env python

from __future__ import print_function, division

import argparse
import os
import re
import sys

try:
    import fontforge
    import psMat
except ImportError:
    sys.stderr.write("The required FontForge modules could not be loaded.\n")
    if sys.version_info.major > 2:
        sys.stderr.write(
            "FontForge only supports Python 2. Please run this script "
            "with the Python 2 executable - e.g. "
            '"python2 {0}"\n'.format(sys.argv[0])
        )
    else:
        sys.stderr.write(
            "You need FontForge with Python bindings for this script to work.\n"
        )
    sys.exit(1)


def parse_command_line():
    """
    Defines and parses the command line arguments for the script.
    """
    parser = argparse.ArgumentParser(
        description="Add one font glyphs (mostly symbols) to another one", add_help=True
    )
    parser.add_argument("target_font_path", help="font file to patch", metavar="target")
    parser.add_argument(
        "--symbols", help="font file with symbols", dest="symbols_font_path"
    )
    parser.add_argument(
        "--rename-as", help="name of the resulting patched font", dest="rename_as"
    )
    return parser.parse_args()


def open_font(font_path):
    """
    Tries to load the font given its location. Exits with a nice error
    message if an invalid path is given.
    """
    try:
        return fontforge.open(font_path)
    except EnvironmentError:
        sys.stderr.write("Unable to find font file {0}\n".format(font_path))
        sys.exit(1)


def force_em_size_to_be_equal(source, target):
    source.em = target.em


class BoundingBox(object):
    def __init__(self, glyph):
        self._xmin, self._ymin, self._xmax, self._ymax = glyph.boundingBox()
        self._width = self._xmax - self._xmin
        self._height = self._ymax - self._ymin

    @property
    def xmin(self):
        return self._xmin

    @property
    def xmax(self):
        return self._xmax

    @property
    def ymin(self):
        return self._ymin

    @property
    def ymax(self):
        return self._ymax

    @property
    def width(self):
        return self._width

    @property
    def height(self):
        return self._height

    @property
    def aspect_ratio(self):
        return float(self._width) / float(self._height)

    @property
    def is_empty(self):
        return self.width == 0 or self.height == 0


def adapt(glyph, magic_glyph, aspect_ratio_cutoff=0.7):
    box = BoundingBox(glyph)
    assert not box.is_empty
    is_wide = box.aspect_ratio >= aspect_ratio_cutoff
    target_box = BoundingBox(magic_glyph)
    target_width = target_box.width + int(is_wide) * magic_glyph.width
    target_height = target_box.height
    # First, we rescale the glyph
    scale = psMat.scale(min(target_height / box.height, target_width / box.width))
    glyph.transform(scale)
    # Next, we center it
    box = BoundingBox(glyph)
    shift_x = (target_width - box.width) / 2 + (target_box.xmin - box.xmin)
    shift_y = (target_height - box.height) / 2 + (target_box.ymin - box.ymin)
    glyph.transform(psMat.translate(shift_x, shift_y))
    # Make the glyph occupy exactly one or two cells
    glyph.width = magic_glyph.width + int(is_wide) * magic_glyph.width
    glyph.vwidth = magic_glyph.vwidth


def main():
    args = parse_command_line()
    symbols = open_font(args.symbols_font_path)
    font = open_font(args.target_font_path)
    force_em_size_to_be_equal(symbols, font)
    if args.rename_as:
        font.fontname = args.rename_as.replace(" ", "")
        font.familyname = args.rename_as
        font.fullname = args.rename_as
        font.appendSFNTName("English (US)", "Preferred Family", font.familyname)
        font.appendSFNTName("English (US)", "Compatible Full", font.fullname)
    magic_glyph = font["X"]
    name_to_codepoint = {}

    for symbol in symbols.glyphs("encoding"):
        if (
            symbol.unicode > 0
            and symbol.codepoint not in font
            and not BoundingBox(symbol).is_empty
        ):
            symbols.selection.select(symbol.encoding)
            symbols.copy()
            glyph = font.createMappedChar(symbol.codepoint)
            glyph.glyphname = symbol.glyphname
            font.selection.select(symbol.codepoint)
            font.paste()
            adapt(glyph, magic_glyph)
            name_to_codepoint[symbol.glyphname] = re.match(
                "U\+([0-9a-fA-F]+)", symbol.codepoint
            ).group(1)

    output_name, extension = os.path.split(args.target_font_path)[1].rsplit(".", 1)
    if args.rename_as:
        output_name = args.rename_as.replace(" ", "")
    font.generate("{}.{}".format(output_name, extension))

    with open("{}.sh".format(output_name), "w") as f:
        f.write("declare -xgA _FONT_AWESOME=(\n")
        for name, codepoint in name_to_codepoint.iteritems():
            f.write("    [{}]={}\n".format(name, codepoint))
        f.write(")\n")


if __name__ == "__main__":
    main()
